// Code generated by engine gate build no edit

//go:generate mockgen -source ./sets.go -destination mocks/sets.go

package v1sets

import (
	gate_v1 "github.com/xdmybl/gate-type/pkg/api/gate/v1"

	"github.com/rotisserie/eris"
	sksets "github.com/solo-io/skv2/contrib/pkg/sets"
	"github.com/solo-io/skv2/pkg/ezkube"
	"k8s.io/apimachinery/pkg/util/sets"
)

type CaCertificateSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*gate_v1.CaCertificate) bool) []*gate_v1.CaCertificate
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*gate_v1.CaCertificate) bool) []*gate_v1.CaCertificate
	// Return the Set as a map of key to resource.
	Map() map[string]*gate_v1.CaCertificate
	// Insert a resource into the set.
	Insert(caCertificate ...*gate_v1.CaCertificate)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(caCertificateSet CaCertificateSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(caCertificate ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(caCertificate ezkube.ResourceId)
	// Return the union with the provided set
	Union(set CaCertificateSet) CaCertificateSet
	// Return the difference with the provided set
	Difference(set CaCertificateSet) CaCertificateSet
	// Return the intersection with the provided set
	Intersection(set CaCertificateSet) CaCertificateSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*gate_v1.CaCertificate, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another CaCertificateSet
	Delta(newSet CaCertificateSet) sksets.ResourceDelta
	// Create a deep copy of the current CaCertificateSet
	Clone() CaCertificateSet
}

func makeGenericCaCertificateSet(caCertificateList []*gate_v1.CaCertificate) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range caCertificateList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type caCertificateSet struct {
	set sksets.ResourceSet
}

func NewCaCertificateSet(caCertificateList ...*gate_v1.CaCertificate) CaCertificateSet {
	return &caCertificateSet{set: makeGenericCaCertificateSet(caCertificateList)}
}

func NewCaCertificateSetFromList(caCertificateList *gate_v1.CaCertificateList) CaCertificateSet {
	list := make([]*gate_v1.CaCertificate, 0, len(caCertificateList.Items))
	for idx := range caCertificateList.Items {
		list = append(list, &caCertificateList.Items[idx])
	}
	return &caCertificateSet{set: makeGenericCaCertificateSet(list)}
}

func (s *caCertificateSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *caCertificateSet) List(filterResource ...func(*gate_v1.CaCertificate) bool) []*gate_v1.CaCertificate {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*gate_v1.CaCertificate))
		})
	}

	objs := s.Generic().List(genericFilters...)
	caCertificateList := make([]*gate_v1.CaCertificate, 0, len(objs))
	for _, obj := range objs {
		caCertificateList = append(caCertificateList, obj.(*gate_v1.CaCertificate))
	}
	return caCertificateList
}

func (s *caCertificateSet) UnsortedList(filterResource ...func(*gate_v1.CaCertificate) bool) []*gate_v1.CaCertificate {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*gate_v1.CaCertificate))
		})
	}

	var caCertificateList []*gate_v1.CaCertificate
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		caCertificateList = append(caCertificateList, obj.(*gate_v1.CaCertificate))
	}
	return caCertificateList
}

func (s *caCertificateSet) Map() map[string]*gate_v1.CaCertificate {
	if s == nil {
		return nil
	}

	newMap := map[string]*gate_v1.CaCertificate{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*gate_v1.CaCertificate)
	}
	return newMap
}

func (s *caCertificateSet) Insert(
	caCertificateList ...*gate_v1.CaCertificate,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range caCertificateList {
		s.Generic().Insert(obj)
	}
}

func (s *caCertificateSet) Has(caCertificate ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(caCertificate)
}

func (s *caCertificateSet) Equal(
	caCertificateSet CaCertificateSet,
) bool {
	if s == nil {
		return caCertificateSet == nil
	}
	return s.Generic().Equal(caCertificateSet.Generic())
}

func (s *caCertificateSet) Delete(CaCertificate ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(CaCertificate)
}

func (s *caCertificateSet) Union(set CaCertificateSet) CaCertificateSet {
	if s == nil {
		return set
	}
	return NewCaCertificateSet(append(s.List(), set.List()...)...)
}

func (s *caCertificateSet) Difference(set CaCertificateSet) CaCertificateSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &caCertificateSet{set: newSet}
}

func (s *caCertificateSet) Intersection(set CaCertificateSet) CaCertificateSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var caCertificateList []*gate_v1.CaCertificate
	for _, obj := range newSet.List() {
		caCertificateList = append(caCertificateList, obj.(*gate_v1.CaCertificate))
	}
	return NewCaCertificateSet(caCertificateList...)
}

func (s *caCertificateSet) Find(id ezkube.ResourceId) (*gate_v1.CaCertificate, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find CaCertificate %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&gate_v1.CaCertificate{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*gate_v1.CaCertificate), nil
}

func (s *caCertificateSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *caCertificateSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *caCertificateSet) Delta(newSet CaCertificateSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *caCertificateSet) Clone() CaCertificateSet {
	if s == nil {
		return nil
	}
	return &caCertificateSet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type SslCertificateSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*gate_v1.SslCertificate) bool) []*gate_v1.SslCertificate
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*gate_v1.SslCertificate) bool) []*gate_v1.SslCertificate
	// Return the Set as a map of key to resource.
	Map() map[string]*gate_v1.SslCertificate
	// Insert a resource into the set.
	Insert(sslCertificate ...*gate_v1.SslCertificate)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(sslCertificateSet SslCertificateSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(sslCertificate ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(sslCertificate ezkube.ResourceId)
	// Return the union with the provided set
	Union(set SslCertificateSet) SslCertificateSet
	// Return the difference with the provided set
	Difference(set SslCertificateSet) SslCertificateSet
	// Return the intersection with the provided set
	Intersection(set SslCertificateSet) SslCertificateSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*gate_v1.SslCertificate, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another SslCertificateSet
	Delta(newSet SslCertificateSet) sksets.ResourceDelta
	// Create a deep copy of the current SslCertificateSet
	Clone() SslCertificateSet
}

func makeGenericSslCertificateSet(sslCertificateList []*gate_v1.SslCertificate) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range sslCertificateList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type sslCertificateSet struct {
	set sksets.ResourceSet
}

func NewSslCertificateSet(sslCertificateList ...*gate_v1.SslCertificate) SslCertificateSet {
	return &sslCertificateSet{set: makeGenericSslCertificateSet(sslCertificateList)}
}

func NewSslCertificateSetFromList(sslCertificateList *gate_v1.SslCertificateList) SslCertificateSet {
	list := make([]*gate_v1.SslCertificate, 0, len(sslCertificateList.Items))
	for idx := range sslCertificateList.Items {
		list = append(list, &sslCertificateList.Items[idx])
	}
	return &sslCertificateSet{set: makeGenericSslCertificateSet(list)}
}

func (s *sslCertificateSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *sslCertificateSet) List(filterResource ...func(*gate_v1.SslCertificate) bool) []*gate_v1.SslCertificate {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*gate_v1.SslCertificate))
		})
	}

	objs := s.Generic().List(genericFilters...)
	sslCertificateList := make([]*gate_v1.SslCertificate, 0, len(objs))
	for _, obj := range objs {
		sslCertificateList = append(sslCertificateList, obj.(*gate_v1.SslCertificate))
	}
	return sslCertificateList
}

func (s *sslCertificateSet) UnsortedList(filterResource ...func(*gate_v1.SslCertificate) bool) []*gate_v1.SslCertificate {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*gate_v1.SslCertificate))
		})
	}

	var sslCertificateList []*gate_v1.SslCertificate
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		sslCertificateList = append(sslCertificateList, obj.(*gate_v1.SslCertificate))
	}
	return sslCertificateList
}

func (s *sslCertificateSet) Map() map[string]*gate_v1.SslCertificate {
	if s == nil {
		return nil
	}

	newMap := map[string]*gate_v1.SslCertificate{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*gate_v1.SslCertificate)
	}
	return newMap
}

func (s *sslCertificateSet) Insert(
	sslCertificateList ...*gate_v1.SslCertificate,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range sslCertificateList {
		s.Generic().Insert(obj)
	}
}

func (s *sslCertificateSet) Has(sslCertificate ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(sslCertificate)
}

func (s *sslCertificateSet) Equal(
	sslCertificateSet SslCertificateSet,
) bool {
	if s == nil {
		return sslCertificateSet == nil
	}
	return s.Generic().Equal(sslCertificateSet.Generic())
}

func (s *sslCertificateSet) Delete(SslCertificate ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(SslCertificate)
}

func (s *sslCertificateSet) Union(set SslCertificateSet) SslCertificateSet {
	if s == nil {
		return set
	}
	return NewSslCertificateSet(append(s.List(), set.List()...)...)
}

func (s *sslCertificateSet) Difference(set SslCertificateSet) SslCertificateSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &sslCertificateSet{set: newSet}
}

func (s *sslCertificateSet) Intersection(set SslCertificateSet) SslCertificateSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var sslCertificateList []*gate_v1.SslCertificate
	for _, obj := range newSet.List() {
		sslCertificateList = append(sslCertificateList, obj.(*gate_v1.SslCertificate))
	}
	return NewSslCertificateSet(sslCertificateList...)
}

func (s *sslCertificateSet) Find(id ezkube.ResourceId) (*gate_v1.SslCertificate, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find SslCertificate %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&gate_v1.SslCertificate{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*gate_v1.SslCertificate), nil
}

func (s *sslCertificateSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *sslCertificateSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *sslCertificateSet) Delta(newSet SslCertificateSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *sslCertificateSet) Clone() SslCertificateSet {
	if s == nil {
		return nil
	}
	return &sslCertificateSet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}

type UpstreamSet interface {
	// Get the set stored keys
	Keys() sets.String
	// List of resources stored in the set. Pass an optional filter function to filter on the list.
	List(filterResource ...func(*gate_v1.Upstream) bool) []*gate_v1.Upstream
	// Unsorted list of resources stored in the set. Pass an optional filter function to filter on the list.
	UnsortedList(filterResource ...func(*gate_v1.Upstream) bool) []*gate_v1.Upstream
	// Return the Set as a map of key to resource.
	Map() map[string]*gate_v1.Upstream
	// Insert a resource into the set.
	Insert(upstream ...*gate_v1.Upstream)
	// Compare the equality of the keys in two sets (not the resources themselves)
	Equal(upstreamSet UpstreamSet) bool
	// Check if the set contains a key matching the resource (not the resource itself)
	Has(upstream ezkube.ResourceId) bool
	// Delete the key matching the resource
	Delete(upstream ezkube.ResourceId)
	// Return the union with the provided set
	Union(set UpstreamSet) UpstreamSet
	// Return the difference with the provided set
	Difference(set UpstreamSet) UpstreamSet
	// Return the intersection with the provided set
	Intersection(set UpstreamSet) UpstreamSet
	// Find the resource with the given ID
	Find(id ezkube.ResourceId) (*gate_v1.Upstream, error)
	// Get the length of the set
	Length() int
	// returns the generic implementation of the set
	Generic() sksets.ResourceSet
	// returns the delta between this and and another UpstreamSet
	Delta(newSet UpstreamSet) sksets.ResourceDelta
	// Create a deep copy of the current UpstreamSet
	Clone() UpstreamSet
}

func makeGenericUpstreamSet(upstreamList []*gate_v1.Upstream) sksets.ResourceSet {
	var genericResources []ezkube.ResourceId
	for _, obj := range upstreamList {
		genericResources = append(genericResources, obj)
	}
	return sksets.NewResourceSet(genericResources...)
}

type upstreamSet struct {
	set sksets.ResourceSet
}

func NewUpstreamSet(upstreamList ...*gate_v1.Upstream) UpstreamSet {
	return &upstreamSet{set: makeGenericUpstreamSet(upstreamList)}
}

func NewUpstreamSetFromList(upstreamList *gate_v1.UpstreamList) UpstreamSet {
	list := make([]*gate_v1.Upstream, 0, len(upstreamList.Items))
	for idx := range upstreamList.Items {
		list = append(list, &upstreamList.Items[idx])
	}
	return &upstreamSet{set: makeGenericUpstreamSet(list)}
}

func (s *upstreamSet) Keys() sets.String {
	if s == nil {
		return sets.String{}
	}
	return s.Generic().Keys()
}

func (s *upstreamSet) List(filterResource ...func(*gate_v1.Upstream) bool) []*gate_v1.Upstream {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*gate_v1.Upstream))
		})
	}

	objs := s.Generic().List(genericFilters...)
	upstreamList := make([]*gate_v1.Upstream, 0, len(objs))
	for _, obj := range objs {
		upstreamList = append(upstreamList, obj.(*gate_v1.Upstream))
	}
	return upstreamList
}

func (s *upstreamSet) UnsortedList(filterResource ...func(*gate_v1.Upstream) bool) []*gate_v1.Upstream {
	if s == nil {
		return nil
	}
	var genericFilters []func(ezkube.ResourceId) bool
	for _, filter := range filterResource {
		filter := filter
		genericFilters = append(genericFilters, func(obj ezkube.ResourceId) bool {
			return filter(obj.(*gate_v1.Upstream))
		})
	}

	var upstreamList []*gate_v1.Upstream
	for _, obj := range s.Generic().UnsortedList(genericFilters...) {
		upstreamList = append(upstreamList, obj.(*gate_v1.Upstream))
	}
	return upstreamList
}

func (s *upstreamSet) Map() map[string]*gate_v1.Upstream {
	if s == nil {
		return nil
	}

	newMap := map[string]*gate_v1.Upstream{}
	for k, v := range s.Generic().Map() {
		newMap[k] = v.(*gate_v1.Upstream)
	}
	return newMap
}

func (s *upstreamSet) Insert(
	upstreamList ...*gate_v1.Upstream,
) {
	if s == nil {
		panic("cannot insert into nil set")
	}

	for _, obj := range upstreamList {
		s.Generic().Insert(obj)
	}
}

func (s *upstreamSet) Has(upstream ezkube.ResourceId) bool {
	if s == nil {
		return false
	}
	return s.Generic().Has(upstream)
}

func (s *upstreamSet) Equal(
	upstreamSet UpstreamSet,
) bool {
	if s == nil {
		return upstreamSet == nil
	}
	return s.Generic().Equal(upstreamSet.Generic())
}

func (s *upstreamSet) Delete(Upstream ezkube.ResourceId) {
	if s == nil {
		return
	}
	s.Generic().Delete(Upstream)
}

func (s *upstreamSet) Union(set UpstreamSet) UpstreamSet {
	if s == nil {
		return set
	}
	return NewUpstreamSet(append(s.List(), set.List()...)...)
}

func (s *upstreamSet) Difference(set UpstreamSet) UpstreamSet {
	if s == nil {
		return set
	}
	newSet := s.Generic().Difference(set.Generic())
	return &upstreamSet{set: newSet}
}

func (s *upstreamSet) Intersection(set UpstreamSet) UpstreamSet {
	if s == nil {
		return nil
	}
	newSet := s.Generic().Intersection(set.Generic())
	var upstreamList []*gate_v1.Upstream
	for _, obj := range newSet.List() {
		upstreamList = append(upstreamList, obj.(*gate_v1.Upstream))
	}
	return NewUpstreamSet(upstreamList...)
}

func (s *upstreamSet) Find(id ezkube.ResourceId) (*gate_v1.Upstream, error) {
	if s == nil {
		return nil, eris.Errorf("empty set, cannot find Upstream %v", sksets.Key(id))
	}
	obj, err := s.Generic().Find(&gate_v1.Upstream{}, id)
	if err != nil {
		return nil, err
	}

	return obj.(*gate_v1.Upstream), nil
}

func (s *upstreamSet) Length() int {
	if s == nil {
		return 0
	}
	return s.Generic().Length()
}

func (s *upstreamSet) Generic() sksets.ResourceSet {
	if s == nil {
		return nil
	}
	return s.set
}

func (s *upstreamSet) Delta(newSet UpstreamSet) sksets.ResourceDelta {
	if s == nil {
		return sksets.ResourceDelta{
			Inserted: newSet.Generic(),
		}
	}
	return s.Generic().Delta(newSet.Generic())
}

func (s *upstreamSet) Clone() UpstreamSet {
	if s == nil {
		return nil
	}
	return &upstreamSet{set: sksets.NewResourceSet(s.Generic().Clone().List()...)}
}
