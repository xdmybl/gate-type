// Code generated by engine gate build no edit

//go:generate mockgen -source ./reconcilers.go -destination mocks/reconcilers.go

// Definitions for the Kubernetes Controllers
package controller

import (
	"context"

	gate_xdmybl_io_v1 "github.com/xdmybl/gate-type/pkg/api/gate.xdmybl.io/v1"

	"github.com/pkg/errors"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the CaCertificate Resource.
// implemented by the user
type CaCertificateReconciler interface {
	ReconcileCaCertificate(obj *gate_xdmybl_io_v1.CaCertificate) (reconcile.Result, error)
}

// Reconcile deletion events for the CaCertificate Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type CaCertificateDeletionReconciler interface {
	ReconcileCaCertificateDeletion(req reconcile.Request) error
}

type CaCertificateReconcilerFuncs struct {
	OnReconcileCaCertificate         func(obj *gate_xdmybl_io_v1.CaCertificate) (reconcile.Result, error)
	OnReconcileCaCertificateDeletion func(req reconcile.Request) error
}

func (f *CaCertificateReconcilerFuncs) ReconcileCaCertificate(obj *gate_xdmybl_io_v1.CaCertificate) (reconcile.Result, error) {
	if f.OnReconcileCaCertificate == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileCaCertificate(obj)
}

func (f *CaCertificateReconcilerFuncs) ReconcileCaCertificateDeletion(req reconcile.Request) error {
	if f.OnReconcileCaCertificateDeletion == nil {
		return nil
	}
	return f.OnReconcileCaCertificateDeletion(req)
}

// Reconcile and finalize the CaCertificate Resource
// implemented by the user
type CaCertificateFinalizer interface {
	CaCertificateReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	CaCertificateFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeCaCertificate(obj *gate_xdmybl_io_v1.CaCertificate) error
}

type CaCertificateReconcileLoop interface {
	RunCaCertificateReconciler(ctx context.Context, rec CaCertificateReconciler, predicates ...predicate.Predicate) error
}

type caCertificateReconcileLoop struct {
	loop reconcile.Loop
}

func NewCaCertificateReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) CaCertificateReconcileLoop {
	return &caCertificateReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &gate_xdmybl_io_v1.CaCertificate{}, options),
	}
}

func (c *caCertificateReconcileLoop) RunCaCertificateReconciler(ctx context.Context, reconciler CaCertificateReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericCaCertificateReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(CaCertificateFinalizer); ok {
		reconcilerWrapper = genericCaCertificateFinalizer{
			genericCaCertificateReconciler: genericReconciler,
			finalizingReconciler:           finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericCaCertificateHandler implements a generic reconcile.Reconciler
type genericCaCertificateReconciler struct {
	reconciler CaCertificateReconciler
}

func (r genericCaCertificateReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*gate_xdmybl_io_v1.CaCertificate)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: CaCertificate handler received event for %T", object)
	}
	return r.reconciler.ReconcileCaCertificate(obj)
}

func (r genericCaCertificateReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(CaCertificateDeletionReconciler); ok {
		return deletionReconciler.ReconcileCaCertificateDeletion(request)
	}
	return nil
}

// genericCaCertificateFinalizer implements a generic reconcile.FinalizingReconciler
type genericCaCertificateFinalizer struct {
	genericCaCertificateReconciler
	finalizingReconciler CaCertificateFinalizer
}

func (r genericCaCertificateFinalizer) FinalizerName() string {
	return r.finalizingReconciler.CaCertificateFinalizerName()
}

func (r genericCaCertificateFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*gate_xdmybl_io_v1.CaCertificate)
	if !ok {
		return errors.Errorf("internal error: CaCertificate handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeCaCertificate(obj)
}

// Reconcile Upsert events for the Certificate Resource.
// implemented by the user
type CertificateReconciler interface {
	ReconcileCertificate(obj *gate_xdmybl_io_v1.Certificate) (reconcile.Result, error)
}

// Reconcile deletion events for the Certificate Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type CertificateDeletionReconciler interface {
	ReconcileCertificateDeletion(req reconcile.Request) error
}

type CertificateReconcilerFuncs struct {
	OnReconcileCertificate         func(obj *gate_xdmybl_io_v1.Certificate) (reconcile.Result, error)
	OnReconcileCertificateDeletion func(req reconcile.Request) error
}

func (f *CertificateReconcilerFuncs) ReconcileCertificate(obj *gate_xdmybl_io_v1.Certificate) (reconcile.Result, error) {
	if f.OnReconcileCertificate == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileCertificate(obj)
}

func (f *CertificateReconcilerFuncs) ReconcileCertificateDeletion(req reconcile.Request) error {
	if f.OnReconcileCertificateDeletion == nil {
		return nil
	}
	return f.OnReconcileCertificateDeletion(req)
}

// Reconcile and finalize the Certificate Resource
// implemented by the user
type CertificateFinalizer interface {
	CertificateReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	CertificateFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeCertificate(obj *gate_xdmybl_io_v1.Certificate) error
}

type CertificateReconcileLoop interface {
	RunCertificateReconciler(ctx context.Context, rec CertificateReconciler, predicates ...predicate.Predicate) error
}

type certificateReconcileLoop struct {
	loop reconcile.Loop
}

func NewCertificateReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) CertificateReconcileLoop {
	return &certificateReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &gate_xdmybl_io_v1.Certificate{}, options),
	}
}

func (c *certificateReconcileLoop) RunCertificateReconciler(ctx context.Context, reconciler CertificateReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericCertificateReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(CertificateFinalizer); ok {
		reconcilerWrapper = genericCertificateFinalizer{
			genericCertificateReconciler: genericReconciler,
			finalizingReconciler:         finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericCertificateHandler implements a generic reconcile.Reconciler
type genericCertificateReconciler struct {
	reconciler CertificateReconciler
}

func (r genericCertificateReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*gate_xdmybl_io_v1.Certificate)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: Certificate handler received event for %T", object)
	}
	return r.reconciler.ReconcileCertificate(obj)
}

func (r genericCertificateReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(CertificateDeletionReconciler); ok {
		return deletionReconciler.ReconcileCertificateDeletion(request)
	}
	return nil
}

// genericCertificateFinalizer implements a generic reconcile.FinalizingReconciler
type genericCertificateFinalizer struct {
	genericCertificateReconciler
	finalizingReconciler CertificateFinalizer
}

func (r genericCertificateFinalizer) FinalizerName() string {
	return r.finalizingReconciler.CertificateFinalizerName()
}

func (r genericCertificateFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*gate_xdmybl_io_v1.Certificate)
	if !ok {
		return errors.Errorf("internal error: Certificate handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeCertificate(obj)
}

// Reconcile Upsert events for the Upstream Resource.
// implemented by the user
type UpstreamReconciler interface {
	ReconcileUpstream(obj *gate_xdmybl_io_v1.Upstream) (reconcile.Result, error)
}

// Reconcile deletion events for the Upstream Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type UpstreamDeletionReconciler interface {
	ReconcileUpstreamDeletion(req reconcile.Request) error
}

type UpstreamReconcilerFuncs struct {
	OnReconcileUpstream         func(obj *gate_xdmybl_io_v1.Upstream) (reconcile.Result, error)
	OnReconcileUpstreamDeletion func(req reconcile.Request) error
}

func (f *UpstreamReconcilerFuncs) ReconcileUpstream(obj *gate_xdmybl_io_v1.Upstream) (reconcile.Result, error) {
	if f.OnReconcileUpstream == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileUpstream(obj)
}

func (f *UpstreamReconcilerFuncs) ReconcileUpstreamDeletion(req reconcile.Request) error {
	if f.OnReconcileUpstreamDeletion == nil {
		return nil
	}
	return f.OnReconcileUpstreamDeletion(req)
}

// Reconcile and finalize the Upstream Resource
// implemented by the user
type UpstreamFinalizer interface {
	UpstreamReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	UpstreamFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeUpstream(obj *gate_xdmybl_io_v1.Upstream) error
}

type UpstreamReconcileLoop interface {
	RunUpstreamReconciler(ctx context.Context, rec UpstreamReconciler, predicates ...predicate.Predicate) error
}

type upstreamReconcileLoop struct {
	loop reconcile.Loop
}

func NewUpstreamReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) UpstreamReconcileLoop {
	return &upstreamReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &gate_xdmybl_io_v1.Upstream{}, options),
	}
}

func (c *upstreamReconcileLoop) RunUpstreamReconciler(ctx context.Context, reconciler UpstreamReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericUpstreamReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(UpstreamFinalizer); ok {
		reconcilerWrapper = genericUpstreamFinalizer{
			genericUpstreamReconciler: genericReconciler,
			finalizingReconciler:      finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericUpstreamHandler implements a generic reconcile.Reconciler
type genericUpstreamReconciler struct {
	reconciler UpstreamReconciler
}

func (r genericUpstreamReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*gate_xdmybl_io_v1.Upstream)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: Upstream handler received event for %T", object)
	}
	return r.reconciler.ReconcileUpstream(obj)
}

func (r genericUpstreamReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(UpstreamDeletionReconciler); ok {
		return deletionReconciler.ReconcileUpstreamDeletion(request)
	}
	return nil
}

// genericUpstreamFinalizer implements a generic reconcile.FinalizingReconciler
type genericUpstreamFinalizer struct {
	genericUpstreamReconciler
	finalizingReconciler UpstreamFinalizer
}

func (r genericUpstreamFinalizer) FinalizerName() string {
	return r.finalizingReconciler.UpstreamFinalizerName()
}

func (r genericUpstreamFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*gate_xdmybl_io_v1.Upstream)
	if !ok {
		return errors.Errorf("internal error: Upstream handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeUpstream(obj)
}

// Reconcile Upsert events for the Gateway Resource.
// implemented by the user
type GatewayReconciler interface {
	ReconcileGateway(obj *gate_xdmybl_io_v1.Gateway) (reconcile.Result, error)
}

// Reconcile deletion events for the Gateway Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type GatewayDeletionReconciler interface {
	ReconcileGatewayDeletion(req reconcile.Request) error
}

type GatewayReconcilerFuncs struct {
	OnReconcileGateway         func(obj *gate_xdmybl_io_v1.Gateway) (reconcile.Result, error)
	OnReconcileGatewayDeletion func(req reconcile.Request) error
}

func (f *GatewayReconcilerFuncs) ReconcileGateway(obj *gate_xdmybl_io_v1.Gateway) (reconcile.Result, error) {
	if f.OnReconcileGateway == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileGateway(obj)
}

func (f *GatewayReconcilerFuncs) ReconcileGatewayDeletion(req reconcile.Request) error {
	if f.OnReconcileGatewayDeletion == nil {
		return nil
	}
	return f.OnReconcileGatewayDeletion(req)
}

// Reconcile and finalize the Gateway Resource
// implemented by the user
type GatewayFinalizer interface {
	GatewayReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	GatewayFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeGateway(obj *gate_xdmybl_io_v1.Gateway) error
}

type GatewayReconcileLoop interface {
	RunGatewayReconciler(ctx context.Context, rec GatewayReconciler, predicates ...predicate.Predicate) error
}

type gatewayReconcileLoop struct {
	loop reconcile.Loop
}

func NewGatewayReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) GatewayReconcileLoop {
	return &gatewayReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &gate_xdmybl_io_v1.Gateway{}, options),
	}
}

func (c *gatewayReconcileLoop) RunGatewayReconciler(ctx context.Context, reconciler GatewayReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericGatewayReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(GatewayFinalizer); ok {
		reconcilerWrapper = genericGatewayFinalizer{
			genericGatewayReconciler: genericReconciler,
			finalizingReconciler:     finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericGatewayHandler implements a generic reconcile.Reconciler
type genericGatewayReconciler struct {
	reconciler GatewayReconciler
}

func (r genericGatewayReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*gate_xdmybl_io_v1.Gateway)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: Gateway handler received event for %T", object)
	}
	return r.reconciler.ReconcileGateway(obj)
}

func (r genericGatewayReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(GatewayDeletionReconciler); ok {
		return deletionReconciler.ReconcileGatewayDeletion(request)
	}
	return nil
}

// genericGatewayFinalizer implements a generic reconcile.FinalizingReconciler
type genericGatewayFinalizer struct {
	genericGatewayReconciler
	finalizingReconciler GatewayFinalizer
}

func (r genericGatewayFinalizer) FinalizerName() string {
	return r.finalizingReconciler.GatewayFinalizerName()
}

func (r genericGatewayFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*gate_xdmybl_io_v1.Gateway)
	if !ok {
		return errors.Errorf("internal error: Gateway handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeGateway(obj)
}

// Reconcile Upsert events for the Filter Resource.
// implemented by the user
type FilterReconciler interface {
	ReconcileFilter(obj *gate_xdmybl_io_v1.Filter) (reconcile.Result, error)
}

// Reconcile deletion events for the Filter Resource.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type FilterDeletionReconciler interface {
	ReconcileFilterDeletion(req reconcile.Request) error
}

type FilterReconcilerFuncs struct {
	OnReconcileFilter         func(obj *gate_xdmybl_io_v1.Filter) (reconcile.Result, error)
	OnReconcileFilterDeletion func(req reconcile.Request) error
}

func (f *FilterReconcilerFuncs) ReconcileFilter(obj *gate_xdmybl_io_v1.Filter) (reconcile.Result, error) {
	if f.OnReconcileFilter == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileFilter(obj)
}

func (f *FilterReconcilerFuncs) ReconcileFilterDeletion(req reconcile.Request) error {
	if f.OnReconcileFilterDeletion == nil {
		return nil
	}
	return f.OnReconcileFilterDeletion(req)
}

// Reconcile and finalize the Filter Resource
// implemented by the user
type FilterFinalizer interface {
	FilterReconciler

	// name of the finalizer used by this handler.
	// finalizer names should be unique for a single task
	FilterFinalizerName() string

	// finalize the object before it is deleted.
	// Watchers created with a finalizing handler will a
	FinalizeFilter(obj *gate_xdmybl_io_v1.Filter) error
}

type FilterReconcileLoop interface {
	RunFilterReconciler(ctx context.Context, rec FilterReconciler, predicates ...predicate.Predicate) error
}

type filterReconcileLoop struct {
	loop reconcile.Loop
}

func NewFilterReconcileLoop(name string, mgr manager.Manager, options reconcile.Options) FilterReconcileLoop {
	return &filterReconcileLoop{
		// empty cluster indicates this reconciler is built for the local cluster
		loop: reconcile.NewLoop(name, "", mgr, &gate_xdmybl_io_v1.Filter{}, options),
	}
}

func (c *filterReconcileLoop) RunFilterReconciler(ctx context.Context, reconciler FilterReconciler, predicates ...predicate.Predicate) error {
	genericReconciler := genericFilterReconciler{
		reconciler: reconciler,
	}

	var reconcilerWrapper reconcile.Reconciler
	if finalizingReconciler, ok := reconciler.(FilterFinalizer); ok {
		reconcilerWrapper = genericFilterFinalizer{
			genericFilterReconciler: genericReconciler,
			finalizingReconciler:    finalizingReconciler,
		}
	} else {
		reconcilerWrapper = genericReconciler
	}
	return c.loop.RunReconciler(ctx, reconcilerWrapper, predicates...)
}

// genericFilterHandler implements a generic reconcile.Reconciler
type genericFilterReconciler struct {
	reconciler FilterReconciler
}

func (r genericFilterReconciler) Reconcile(object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*gate_xdmybl_io_v1.Filter)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: Filter handler received event for %T", object)
	}
	return r.reconciler.ReconcileFilter(obj)
}

func (r genericFilterReconciler) ReconcileDeletion(request reconcile.Request) error {
	if deletionReconciler, ok := r.reconciler.(FilterDeletionReconciler); ok {
		return deletionReconciler.ReconcileFilterDeletion(request)
	}
	return nil
}

// genericFilterFinalizer implements a generic reconcile.FinalizingReconciler
type genericFilterFinalizer struct {
	genericFilterReconciler
	finalizingReconciler FilterFinalizer
}

func (r genericFilterFinalizer) FinalizerName() string {
	return r.finalizingReconciler.FilterFinalizerName()
}

func (r genericFilterFinalizer) Finalize(object ezkube.Object) error {
	obj, ok := object.(*gate_xdmybl_io_v1.Filter)
	if !ok {
		return errors.Errorf("internal error: Filter handler received event for %T", object)
	}
	return r.finalizingReconciler.FinalizeFilter(obj)
}
